package backup

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"
)

// Format handling for DNS record serialization and deserialization.

// FormatHandler defines the interface for DNS record format serialization and deserialization.
type FormatHandler interface {
	// Serialize converts a DNSRecordSet to bytes for file storage
	Serialize(recordSet *DNSRecordSet) ([]byte, error)
	// Deserialize converts bytes from file storage to a DNSRecordSet
	Deserialize(data []byte) (*DNSRecordSet, error)
	// FileExtension returns the preferred file extension for this format
	FileExtension() string
	// Name returns the human-readable name of this format
	Name() string
}

// JSONFormatHandler handles JSON serialization and deserialization of DNS records.
type JSONFormatHandler struct{}

// Serialize converts a DNSRecordSet to JSON bytes.
func (h *JSONFormatHandler) Serialize(recordSet *DNSRecordSet) ([]byte, error) {
	return json.MarshalIndent(recordSet, "", "  ")
}

// Deserialize converts JSON bytes to a DNSRecordSet.
func (h *JSONFormatHandler) Deserialize(data []byte) (*DNSRecordSet, error) {
	var recordSet DNSRecordSet
	err := json.Unmarshal(data, &recordSet)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal JSON: %w", err)
	}
	return &recordSet, nil
}

// FileExtension returns the file extension for JSON format.
func (h *JSONFormatHandler) FileExtension() string {
	return ".json"
}

// Name returns the human-readable name for JSON format.
func (h *JSONFormatHandler) Name() string {
	return "JSON"
}

// TextFormatHandler handles human-readable text serialization and deserialization of DNS records.
type TextFormatHandler struct{}

// Serialize converts a DNSRecordSet to human-readable text bytes.
func (h *TextFormatHandler) Serialize(recordSet *DNSRecordSet) ([]byte, error) {
	var builder strings.Builder

	// Header
	builder.WriteString(fmt.Sprintf("DNS Records for %s (Exported: %s)\n", recordSet.Domain, recordSet.ExportedAt.Format("2006-01-02 15:04:05")))
	builder.WriteString(fmt.Sprintf("Provider: %s\n", recordSet.Provider))
	builder.WriteString(fmt.Sprintf("Version: %s\n", recordSet.Version))

	// Attribution from DNS provider
	if recordSet.Attribution != "" {
		builder.WriteString(fmt.Sprintf("%s\n", recordSet.Attribution))
	}
	builder.WriteString("\n")

	// Group records by type
	recordsByType := make(map[string][]DNSRecord)
	for _, record := range recordSet.Records {
		recordsByType[record.Type] = append(recordsByType[record.Type], record)
	}

	// Output each record type section
	for recordType, records := range recordsByType {
		builder.WriteString(fmt.Sprintf("%s Records:\n", recordType))
		for _, record := range records {
			builder.WriteString(fmt.Sprintf("  %s → %s", record.Name, record.Content))

			// Add additional fields
			var details []string
			if record.TTL > 0 {
				details = append(details, fmt.Sprintf("TTL: %d", record.TTL))
			}
			if record.ID != "" {
				details = append(details, fmt.Sprintf("ID: %s", record.ID))
			}
			if record.Priority > 0 {
				details = append(details, fmt.Sprintf("Priority: %d", record.Priority))
			}

			if len(details) > 0 {
				builder.WriteString(fmt.Sprintf(" (%s)", strings.Join(details, ", ")))
			}

			// Add notes if present
			if record.Notes != "" {
				builder.WriteString(fmt.Sprintf("\n    Notes: %s", record.Notes))
			}

			builder.WriteString("\n")
		}
		builder.WriteString("\n")
	}

	return []byte(builder.String()), nil
}

// Deserialize converts text bytes to a DNSRecordSet.
// Note: This is a simplified parser that handles the format generated by Serialize.
func (h *TextFormatHandler) Deserialize(data []byte) (*DNSRecordSet, error) {
	content := string(data)
	lines := strings.Split(content, "\n")

	if len(lines) < 4 {
		return nil, fmt.Errorf("invalid text format: too few lines")
	}

	// Parse header
	var domain, provider, version string
	var exportedAt time.Time

	// Extract domain from first line
	if strings.HasPrefix(lines[0], "DNS Records for ") {
		domainLine := strings.TrimPrefix(lines[0], "DNS Records for ")
		parts := strings.Split(domainLine, " (Exported: ")
		if len(parts) == 2 {
			domain = parts[0]
			dateStr := strings.TrimSuffix(parts[1], ")")
			var err error
			exportedAt, err = time.Parse("2006-01-02 15:04:05", dateStr)
			if err != nil {
				return nil, fmt.Errorf("invalid date format: %w", err)
			}
		}
	}

	// Extract provider
	if strings.HasPrefix(lines[1], "Provider: ") {
		provider = strings.TrimPrefix(lines[1], "Provider: ")
	}

	// Extract version
	if strings.HasPrefix(lines[2], "Version: ") {
		version = strings.TrimPrefix(lines[2], "Version: ")
	}

	if domain == "" || provider == "" || version == "" {
		return nil, fmt.Errorf("invalid text format: missing required header fields")
	}

	recordSet := &DNSRecordSet{
		Domain:     domain,
		Provider:   provider,
		Version:    version,
		ExportedAt: exportedAt,
		Records:    []DNSRecord{},
	}

	// Parse records (simplified implementation)
	var currentRecordType string
	var currentRecord *DNSRecord

	for _, line := range lines[4:] { // Skip header and empty line
		originalLine := line
		line = strings.TrimSpace(line)
		if line == "" {
			// If we have a current record, add it and reset
			if currentRecord != nil {
				recordSet.Records = append(recordSet.Records, *currentRecord)
				currentRecord = nil
			}
			continue
		}

		// Check if this is a record type header
		if strings.HasSuffix(line, " Records:") {
			// Add any pending record before switching types
			if currentRecord != nil {
				recordSet.Records = append(recordSet.Records, *currentRecord)
				currentRecord = nil
			}
			currentRecordType = strings.TrimSuffix(line, " Records:")
			continue
		}

		// Parse record line or notes
		if strings.HasPrefix(originalLine, "    ") && currentRecord != nil {
			// This is a note line for the current record
			if strings.HasPrefix(line, "Notes: ") {
				currentRecord.Notes = strings.TrimPrefix(line, "Notes: ")
			}
		} else if strings.HasPrefix(originalLine, "  ") && currentRecordType != "" {
			// This is a new record line
			// Add any pending record first
			if currentRecord != nil {
				recordSet.Records = append(recordSet.Records, *currentRecord)
			}

			parseLine := strings.TrimLeft(line, " ")
			record, err := h.parseRecordLine(parseLine, currentRecordType)
			if err != nil {
				return nil, fmt.Errorf("failed to parse record line '%s': %w", line, err)
			}
			currentRecord = record
		}
	}

	// Add the last record if there is one
	if currentRecord != nil {
		recordSet.Records = append(recordSet.Records, *currentRecord)
	}

	return recordSet, nil
}

// parseRecordLine parses a single record line from the text format.
func (h *TextFormatHandler) parseRecordLine(line, recordType string) (*DNSRecord, error) {
	// Remove leading spaces
	line = strings.TrimPrefix(line, "  ")

	// Split on " → " to get name and content
	parts := strings.SplitN(line, " → ", 2)
	if len(parts) != 2 {
		return nil, fmt.Errorf("invalid record format: missing arrow separator")
	}

	name := parts[0]
	rest := parts[1]

	// Extract content from details in parentheses
	content := rest
	var details string
	if strings.Contains(rest, " (") && strings.HasSuffix(rest, ")") {
		contentEnd := strings.Index(rest, " (")
		content = rest[:contentEnd]
		details = strings.TrimSuffix(rest[contentEnd+2:], ")")
	}

	record := &DNSRecord{
		Name:    name,
		Type:    recordType,
		Content: content,
		TTL:     3600, // Default TTL
	}

	// Parse details if present
	if details != "" {
		detailParts := strings.Split(details, ", ")
		for _, part := range detailParts {
			if strings.HasPrefix(part, "TTL: ") {
				_, err := fmt.Sscanf(part, "TTL: %d", &record.TTL)
				if err != nil {
					return nil, fmt.Errorf("invalid TTL format: %s", part)
				}
			} else if strings.HasPrefix(part, "ID: ") {
				record.ID = strings.TrimPrefix(part, "ID: ")
			} else if strings.HasPrefix(part, "Priority: ") {
				_, err := fmt.Sscanf(part, "Priority: %d", &record.Priority)
				if err != nil {
					return nil, fmt.Errorf("invalid priority format: %s", part)
				}
			}
		}
	}

	return record, nil
}

// FileExtension returns the file extension for text format.
func (h *TextFormatHandler) FileExtension() string {
	return ".txt"
}

// Name returns the human-readable name for text format.
func (h *TextFormatHandler) Name() string {
	return "Text"
}

// GetFormatHandler returns the appropriate format handler based on the format name.
func GetFormatHandler(format string) (FormatHandler, error) {
	switch strings.ToLower(format) {
	case "json":
		return &JSONFormatHandler{}, nil
	case "txt", "text":
		return &TextFormatHandler{}, nil
	default:
		return nil, fmt.Errorf("unsupported format: %s. Supported formats: json, txt", format)
	}
}

// GetFormatHandlerFromFilename returns the appropriate format handler based on file extension.
func GetFormatHandlerFromFilename(filename string) (FormatHandler, error) {
	filename = strings.ToLower(filename)
	switch {
	case strings.HasSuffix(filename, ".json"):
		return &JSONFormatHandler{}, nil
	case strings.HasSuffix(filename, ".txt"):
		return &TextFormatHandler{}, nil
	default:
		return nil, fmt.Errorf("cannot determine format from filename: %s", filename)
	}
}
